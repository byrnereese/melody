#!/usr/bin/perl -w

# Movable Type (r) Open Source (C) 2001-2010 Six Apart, Ltd.
# This program is distributed under the terms of the
# GNU General Public License, version 2.
#
# $Id$

use strict;
use lib './lib';

sub usage {'[-lang=<lang>] [-base=<plugin id>] -dir=<directory> [-out=<filename>] [-verbose]'}

sub help {
    return q{
        Generated translation files for code and templates.

        -lang=<language> The language code you want to generate a 
                         translation file for, e.g. fr, de, en_us, jp
        -base=<string>   The root class of the package that will be
                         generated. This often corresponds to your
                         plugin's id. 
        -dir=<string>    The root directory of your plugin to scan for 
                         files for translatable strings. 
                         e.g. plugins/MyPluginName/
        -out=<string>    The name of the file to output the contents of
                         the generated translation file into. 
                         Default: <language>.pm
        -verbose         Create more output to help with troubleshooting.
        -help            This message.
    };
}

my $wc           = 0;
my $root_dir     = '.';
my $languagename = 'fr';
my $base         = "MT";
my $verbose      = 0;
my $outfile;
my $help;

require Getopt::Long;
Getopt::Long::GetOptions(
    "lang=s"  => \$languagename,
    "base=s"  => \$base,
    "dir=s"   => \$root_dir,
    "out=s"   => \$outfile,
    "verbose" => \$verbose,
    "help"    => \$help,
);

if ($help) { print help(); exit(1) };

debug("Adding $root_dir to include path");
eval("use lib '$root_dir';");

my $packagename = $base."::L10N::".$languagename;
debug("Generating language file: $packagename");

$outfile ||= $languagename . '.pm';
open OUTFILE,">$outfile" or die "Could not open $outfile to write to: $!";
my $lib_dir = $root_dir . '/lib';
my $yr = ( localtime(time) )[5] + 1900;
my $parent_class = $languagename eq 'en_us' ? 'MT::L10N' : 'MT::L10N::en_us';
my $lex = $base."::L10N::en_us";

print OUTFILE <<"HEADER";
# This language file was generated automatically by the make-l10n script. 
# It was subsequently edited by a translator. 
# 
package $packagename;

use strict;
use $parent_class;
use vars qw( \@ISA \%Lexicon );
\@ISA = qw( $parent_class );

sub encoding { 'utf-8' } 

## The following is the translation table.

\%Lexicon = (
HEADER

%MT::L10N::en_us::Lexicon = ();    ## Suppress warning.

my @phrases;

#require MT::L10N::en_us;
#eval("require MT::L10N::$languagename");
#debug("WARNING: Could not require MT::L10N::$languagename: " . $@) if $@;
#push @phrases, keys %MT::L10N::en_us::Lexicon;

debug("Requiring $lex\n");
eval("require $lex");
if ($@) {
    debug("Getting phrases for $lex");
    my $str = "push \@phrases, keys \%".$lex."::Lexicon";
    debug("Evaling $str");
    eval($str);
    debug("WARNING: Could not load phrases for $lex: " . $@) if $@;
} else {
    debug("WARNING: Could not require $lex: " . $@);
}
use File::Find;
find \&wanted, $root_dir;
print OUTFILE "\n    ## Other phrases, with English translations.\n";
for my $phrase ( @phrases ) {
    print OUTFILE encode_phrase(
                         $phrase,
                         eval(
                                   '$MT::L10N::'
                                 . $languagename
                                 . '::Lexicon{$phrase}'
                         )
    );
}


print OUTFILE "\n    ## Error messages, strings in the app code.\n";
find \&wanted_app, $root_dir;

print OUTFILE <<FOOTER;
);


1;

## New words: $wc
FOOTER

close OUTFILE;

my %SeenPhrase;

sub wanted {
    my $file = $File::Find::name;
    return unless $file =~ /\.(mtml|tmpl|pl|cgi\.pre)$/;
    print OUTFILE "\n    ## $file\n";
    open my $fh, $_ or die "Can't open $_: $!";
    local $_ = do { local $/; <$fh> };
    close $fh;
    while (/<(?:_|MT)_TRANS ([^>]+)>/gi) {
        my ( $msg, %args ) = ($1);
        while ( $msg =~ /(\w+)\s*=\s*(\\?["'])(.*?[^\\])\2/gs ) {    #"

# try avoiding strings ending in escape chars
#        while ($msg =~ /(\w+)\s*=\s*(\\?["'])(.*?)\2/g) {   #"
            $args{$1} = $3;
        }
        next unless $args{phrase};
        next if $SeenPhrase{ $args{phrase} }++;
        next if $args{phrase} =~ /^_[A-Z]/;
        $args{phrase} =~ s/\\\'/\'/sg;
        print OUTFILE encode_phrase(
                             $args{phrase},
                             eval(
                                       '$MT::L10N::'
                                     . $languagename
                                     . '::Lexicon{$args{phrase}}'
                             )
        );
    } ## end while (/<MT_TRANS ([^>]+)>/g)
} ## end sub wanted

sub wanted_app {
    my $file = $File::Find::name;
    return unless $file =~ m!/mt\.js$! || $file =~ /\.(pm|pl|cgi\.pre)$/;
    print OUTFILE "\n    ## $file\n";
    open my $fh, $_ or die "Can't open $_: $!";
    local $_ = do { local $/; <$fh> };
    close $fh;
    if ( $file =~ m/\.js/ ) {
        while (/trans\('(.+?[^\\])'/gs)
        {    # Anything between trans(' and '), including escaped quotes
            my ($phrase) = $1;
            next if $SeenPhrase{$phrase}++;
            next if $phrase =~ /^_[A-Z]/;
            $phrase =~ s/\\\'/\'/sg
              ; # Turn escaped quotes back into regular quotes, because the encode_phrase will re-encode them if needed
            print OUTFILE encode_phrase(
                                 $phrase,
                                 eval(
                                           '$MT::L10N::'
                                         . $languagename
                                         . '::Lexicon{$phrase}'
                                 )
            );
        }
    }
    else {
        while (
            /(?:translate|errtrans|maketext|trans_error)\s*\(\s*("([^"]*?[^\\])"|'([^']*?[^\\])')/gs
          )
        {    #"
                # Try avoiding escape symbols at end of string

#        while (/(?:translate|errtrans|maketext|trans_error)\s*\(\s*("([^"]*)"|'([^']*)')/gs) { #"
            # Translate, errtrans... followed by open and closed brackets with either
            # a double quote followed by non double quotes followed by a double quote
            # or
            # a single quote followed by non single quotes followed by a single quote
            my ($phrase) = ( $2 || $3 );
            next if $SeenPhrase{$phrase}++;
            next if $phrase =~ /^_[A-Z]/;
            print OUTFILE encode_phrase(
                                 $phrase,
                                 eval(
                                           '$MT::L10N::'
                                         . $languagename
                                         . '::Lexicon{$phrase}'
                                 )
            );
        } ## end while (...)
    } ## end else [ if ( $file =~ m/\.js/ )]
} ## end sub wanted_app

sub encode_phrase {
    my ( $l, $r, $words ) = @_;
    $r ||= '';
    $l =~ s/'/\\'/g;
    $r =~ s/'/\\'/g;
    $l =~ s/\\\\/\\/g;
    $r =~ s/\\\\/\\/g;
    $words = wordcount($l);
    $wc += $words if ( $r eq '' );

    if ( $r eq '' ) {
        sprintf qq(    '%s' => '%s', # Translate - New (%s)\n), $l, $l,
          $words;
    }
    else {
        if ( $l eq $r ) {
            sprintf qq(    '%s' => '%s', # Translate - Previous (%s)\n), $l,
              $r, $words;
        }
        else {
            sprintf qq(    '%s' => '%s',\n), $l, $r;
        }
    }
} ## end sub encode_phrase

sub wordcount {
    my $l = shift;
    $l =~ s/[`!"$%^&*()_+={[}\];:@~#,.<>?\\\/]/ /g;    #`
    $l =~ s/\ ([ei])\ ([ge])\ / $1.$2./g;
    my @words = split( /\W*\s+\W*/, $l );    # see the Camel book p.39
    return ( $#words + 1 );
}

sub debug {
    print STDERR $_[0]."\n" if $verbose;
}
